<!doctype html>

<meta charset="utf-8">
<title>Dagre D3 Demo: Sentence Tokenization</title>

<script src="d3.js" charset="utf-8"></script>
<script src="jquery-2.2.1.js"></script>
<script src="dagre-d3.js"></script>

<h1>Dagre D3 Demo: Sentence Tokenization</h1>

<style id="css">
  /* This sets the color for "TK" nodes to a light blue green. */

  g.type-TK > rect {
    fill: #00ffd0;
  }

  text {
    font-weight: 300;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
    font-size: 14px;
  }

  .node rect {
    stroke: #999;
    fill: #fff;
    stroke-width: 1.5px;
  }

  .focused rect{
    stroke: #F46;
    fill: #fff;
  }
  .temp rect{
    stroke: #333;
    fill: #999;
  }
  .edgePath path {
    stroke: #333;
    stroke-width: 1.5px;
  }

</style>

<svg id="svg-canvas" width=960 height=600></svg>

<section>
  <p>An example of visualizing the tokenization of a sentence. This example shows how CSS classes can be applied to a rendered graph.
</section>

<script id="js">
  // Create the input graph
  var g = new dagreD3.graphlib.Graph()
    .setGraph({})
    .setDefaultEdgeLabel(function() {
      return {};
    });

  g.graph().rankdir = "LR";
  g.graph().transition = function(selection) {
    return selection.transition().duration(500);
  };

  // Here we"re setting nodeclass, which is used by our custom drawNodes function
  // below.
  g.setNode(0, {
    label: "TOP",
    class: "type-TOP"
  });
  g.setNode(1, {
    label: "S",
    class: "type-S"
  });
  g.setNode(2, {
    label: "NP",
    class: "type-NP"
  });
  g.setNode(3, {
    label: "DT",
    class: "type-DT"
  });
  g.setNode(4, {
    label: "This",
    class: "type-TK"
  });
  g.setNode(5, {
    label: "VP",
    class: "type-VP"
  });
  g.setNode(6, {
    label: "VBZ",
    class: "type-VBZ"
  });
  g.setNode(7, {
    label: "is",
    class: "type-TK"
  });
  g.setNode(8, {
    label: "NP",
    class: "type-NP"
  });
  g.setNode(9, {
    label: "DT",
    class: "type-DT"
  });
  g.setNode(10, {
    label: "an",
    class: "type-TK"
  });
  g.setNode(11, {
    label: "NN",
    class: "type-NN"
  });
  g.setNode(12, {
    label: "example",
    class: "type-TK"
  });
  g.setNode(13, {
    label: ".",
    class: "type-."
  });
  g.setNode(14, {
    label: "sentence",
    class: "type-TK"
  });
  g.setNode(15, {
    label: "TOP2",
    class: "type-TOP"
  });


  g.nodes().forEach(function(v) {
    var node = g.node(v);
    // Round the corners of the nodes
    //node.rx = node.ry = 5;
  });

  // Set up edges, no special attributes.
  g.setEdge(3, 4,{ arrowhead: "hollowPoint" });
  g.setEdge(2, 3,{ arrowhead: "hollowPoint" });
  g.setEdge(1, 2,{ arrowhead: "hollowPoint" });
  g.setEdge(6, 7,{ arrowhead: "hollowPoint" });
  g.setEdge(5, 6,{ arrowhead: "hollowPoint" });
  g.setEdge(9, 10,{ arrowhead: "hollowPoint" });
  g.setEdge(8, 9,{ arrowhead: "hollowPoint" });
  g.setEdge(11, 12,{ arrowhead: "hollowPoint" });
  g.setEdge(8, 11,{ arrowhead: "hollowPoint" });
  g.setEdge(5, 8,{ arrowhead: "hollowPoint" });
  g.setEdge(1, 5,{ arrowhead: "hollowPoint" });
  g.setEdge(13, 14,{ arrowhead: "hollowPoint" });
  g.setEdge(1, 13,{ arrowhead: "hollowPoint" });
  g.setEdge(0, 1,{ arrowhead: "hollowPoint" });


  //makes the lines smooth
  g.edges().forEach(function(e) {
    var edge = g.edge(e.v, e.w);
    edge.lineInterpolate = 'basis';
  });

  // Create the renderer
  var render = new dagreD3.render();

  // Add our custom arrow (a hollow-point)
  render.arrows().hollowPoint = function normal(parent, id, edge, type) {
    var marker = parent.append("marker")
      .attr("id", id)
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 9)
      .attr("refY", 5)
      .attr("markerUnits", "strokeWidth")
      .attr("markerWidth", 8)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
/*
    var path = marker.append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 z")
      .style("stroke-width", 1)
      .style("stroke-dasharray", "1,0")
      .style("fill", "#fff")
      .style("stroke", "#333")
      */
      // Todo:まーかーをDragしたい。。
    var sel = marker.append("rect").attr("width",10).attr("height",10).style("fill", "#fff")
    .style("stroke", "#333")
    .on("click",function(d,i){
      if (d3.event.defaultPrevented) return;
      d.style("fill", "#666")
    })
    dagreD3.util.applyStyle(sel, edge[type + "Style"]);
  };


  // Set up an SVG group so that we can translate the final graph.
  var svg = d3.select("svg"),
    svgGroup = svg.append("g");

  // Run the renderer. This is what draws the final graph.
  render(svgGroup, g);

  // Center the graph
  var xCenterOffset = (svg.attr("width") - g.graph().width) / 2;
  svgGroup.attr("transform", "translate(" + xCenterOffset + ", 20)");
  svg.attr("height", g.graph().height + 40);

  // Set up zoom support
  var zoom = d3.behavior.zoom().on("zoom", function() {
    svgGroup.attr("transform", "translate(" + d3.event.translate + ")" +
      "scale(" + d3.event.scale + ")");
  });
  svg.call(zoom);

  // Set up drag support
  //give IDs to each of the nodes so that they can be accessed
  svg.selectAll("g.node")
    .attr("id", function(d) {
      return "node" + d;
    });

    g.nodes().forEach(function(v) {
      var node = g.node(v);
      node.customId = "node" + v;
    })

  var nodeDrag = d3.behavior.drag()
    .on("dragstart", dragstart)
    .on("drag", dragmove);
  nodeDrag.call(svg.selectAll("g.node"));

  function clicked(d, i) {
    if (d3.event.defaultPrevented) return; // dragged
    console.time("select"+d)
    focusOn(d)
    console.timeEnd("select"+d)
    //$("#node" + d + " rect").attr("style", "fill:gray")
      //g.setNode(d,{style:"fill: gray"})
      //node.transition().style("fill", "gray");
  }
  svg.selectAll("g.node").on("click", clicked)

  var currentFocusedId = null
  function focusOn(id){
    dagreD3NodeClass(id,{focused:true,temp:false})
    focusOff()
    currentFocusedId = id
    console.time("addmethods"+id)
    addMethods(id)
    console.timeEnd("addmethods"+id)
  }
  function focusOff(){
    dagreD3NodeClass(currentFocusedId,{focused:false})

    d3.selectAll(".temp").each(function(d){
      g.removeNode(d)
    })
    currentFocusedId = null
  }

  function dagreD3NodeClass(id, classobj){
    if(!id) return
    console.time("nodeclass"+id)
    var cls = g.node(id)
    var cla = cls.class.split(" ")
    for(var k in classobj){
      if(classobj[k]){
        if(!cla.some(function(c){return c==k})){
          cla.push(k)
        }
      }else{
        cla = cla.filter(function(c){return c!=k})
      }
    }
    cls.class = cla.join(" ")
    g.setNode(id, cls)
    // d3obj とdagred3objの同期。。こんな。。
    //render(svgGroup, g)
    svgGroup.select("#node"+id).classed(classobj)
    console.timeEnd("nodeclass"+id)
  }

  var mcount = 16
  function addMethod(d,method){

    var m = $.extend(true, {}, method);// ご丁寧にd3は参照データをコピーしないのです

    m.id = "node"+mcount
    g.setNode(mcount,m)
    g.node(mcount).customId = m.id
    dagreD3NodeClass(mcount,{temp:true})

    g.setEdge(d,mcount,{ arrowhead: "hollowPoint" ,id:d + "-" + mcount})
    g.edge(d,mcount).customId = d + "-" + mcount
    g.edge(d,mcount).lineInterpolate = 'basis'
    mcount++
  }
  var methods =[
    {label:"method 1",class:"type-Method"},
//    {label:"method 2",class:"type-Method"},
//    {label:"method 3",class:"type-Method"},
  ]
  function addMethods(d){
    methods.forEach(function(m){
      addMethod(d,m)
    })
    console.time("addmethod render")
    render(svgGroup, g);
    console.timeEnd("addmethod render")
    nodeDrag.call(svg.selectAll("g.node"));
    svg.selectAll("g.node").on("click", clicked)
  }

  svg.selectAll("g.edgePath")
    .attr("id", function(e) {
      return e.v + "-" + e.w;
    })

  g.edges().forEach(function(e) {
    var edge = g.edge(e.v, e.w);
    edge.customId = e.v + "-" + e.w
  });


  /*
  							 var edgeDrag = d3.behavior.drag()
  							 .on("dragstart", dragstart)
  							 .on('drag', function (d) {
  								 translateEdge(g.edge(d.v, d.w), d3.event.dx, d3.event.dy);
  								 $('#' + g.edge(d.v, d.w).customId + " path").attr('d', calcPoints(d));
  								 });

  								 edgeDrag.call(svg.selectAll("g.edgePath"));
  								 */
  function dragstart(d) {
    d3.event.sourceEvent.stopPropagation();
  }

  function dragmove(d) {
    var node = d3.select(this),
      selectedNode = g.node(d);
    var prevX = selectedNode.x,
      prevY = selectedNode.y;

    selectedNode.x += d3.event.dx;
    selectedNode.y += d3.event.dy;
    node.attr('transform', 'translate(' + selectedNode.x + ',' + selectedNode.y + ')');

    var dx = selectedNode.x - prevX,
      dy = selectedNode.y - prevY;

    g.edges().forEach(function(e) {
      if (e.v == d || e.w == d) {
        edge = g.edge(e.v, e.w);
        translateEdge(g.edge(e.v, e.w), dx, dy);
        $('#' + edge.customId + " path").attr('d', calcPoints(e));
      }
    })
  }


  function translateEdge(e, dx, dy) {
    e.points.forEach(function(p) {
      p.x = p.x + dx;
      p.y = p.y + dy;
    });
  }
  //taken from dagre-d3 source code (not the exact same)
  function calcPoints(e) {
    var edge = g.edge(e.v, e.w),
      tail = g.node(e.v),
      head = g.node(e.w);
    var points = edge.points.slice(1, edge.points.length - 1);
    var afterslice = edge.points.slice(1, edge.points.length - 1)
    points.unshift(intersectRect(tail, points[0]));
    points.push(intersectRect(head, points[points.length - 1]));
    return d3.svg.line()
      .x(function(d) {
        return d.x;
      })
      .y(function(d) {
        return d.y;
      })
      .interpolate("basis")
      (points);
  }

  //taken from dagre-d3 source code (not the exact same)
  function intersectRect(node, point) {
    var x = node.x;
    var y = node.y;
    var dx = point.x - x;
    var dy = point.y - y;
    //g.node(node.customId)
    //var w = $("#" + node.customId).attr('width') / 2;
    var w = $("#" + node.customId+" rect").attr('width') / 2;
    var h = $("#" + node.customId+" rect").attr('height') / 2;
    var sx = 0,
      sy = 0;
    if (Math.abs(dy) * w > Math.abs(dx) * h) {
      // Intersection is top or bottom of rect.
      if (dy < 0) {
        h = -h;
      }
      sx = dy === 0 ? 0 : h * dx / dy;
      sy = h;
    } else {
      // Intersection is left or right of rect.
      if (dx < 0) {
        w = -w;
      }
      sx = w;
      sy = dx === 0 ? 0 : w * dy / dx;
    }
    return {
      x: x + sx,
      y: y + sy
    };
  }
</script>
