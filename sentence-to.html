<!doctype html>

<meta charset="utf-8">
<title>Dagre D3 Demo: Sentence Tokenization</title>

<script src="d3.js" charset="utf-8"></script>
<script src="jquery-2.2.1.js"></script>
<script src="dagre-d3.js"></script>

<h1>Dagre D3 Demo: Sentence Tokenization</h1>

<style id="css">
  /* This sets the color for "TK" nodes to a light blue green. */

  g.type-TK > rect {
    fill: #00ffd0;
  }

  text {
    font-weight: 300;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
    font-size: 14px;
  }

  .node rect {
    stroke: #999;
    fill: #fff;
    stroke-width: 1.5px;
  }

  .focused rect {
    stroke: #F46;
    fill: #fff;
  }

  .temp rect {
    stroke: #333;
    fill: #999;
  }

  .edgePath path {
    stroke: #333;
    stroke-width: 1.5px;
  }
</style>

<svg id="svg-canvas" width=960 height=600></svg>

<section>
  <p>An example of visualizing the tokenization of a sentence. This example shows how CSS classes can be applied to a rendered graph.
</section>

<script id="js">
  // Create the input graph
  var g = new dagreD3.graphlib.Graph()
    .setGraph({})
    .setDefaultEdgeLabel(function() {
      return {};
    });

  g.graph().rankdir = "LR";
  g.graph().transition = function(selection) {
    return selection.transition().duration(500);
  };

  // Here we"re setting nodeclass, which is used by our custom drawNodes function
  // below.
  var data = {
    "n0": {
      id: "n0",
      label: "TOP",
      class: "type-TOP",
      //to: ["n1"],
      rx: 5,
      ry: 5,
    },
    "n1": {
      id: "n1",
      label: "S",
      class: "type-S",
      //to: ["n2", "n5", "n13"],
      from: ["n0"],
      rx: 15,
      ry: 15,
    },
    "n2": {
      id: "n2",
      label: "NP",
      class: "type-NP",
      //to: ["n3"]
      from: ["n1"]
    },
    "n3": {
      id: "n3",
      label: "DT",
      class: "type-DT",
      //to: ["n4"]
      from: ["n2"]
    },
    "n4": {
      id: "n4",
      label: "This",
      class: "type-TK",
      //to: []
      from: ["n3"]
    },
    "n5": {
      id: "n5",
      label: "VP",
      class: "type-VP",
      //to: ["n6", "n8"]
      from: ["n1"]
    },
    "n6": {
      id: "n6",
      label: "VBZ",
      class: "type-VBZ",
      //to: ["n7"]
      from: ["n5"]
    },
    "n7": {
      id: "n7",
      label: "is",
      class: "type-TK",
      //to: []
      from: ["n6"]
    },
    "n8": {
      id: "n8",
      label: "NP",
      class: "type-NP",
      //to: ["n9", "n11"]
      from: ["n5"]
    },
    "n9": {
      id: "n9",
      label: "DT",
      class: "type-DT",
      //to: ["n10"]
      from: ["n8"]
    },
    "n10": {
      id: "n10",
      label: "an",
      class: "type-TK",
      //to: []
      from: ["n9"]
    },
    "n11": {
      id: "n11",
      label: "NN",
      class: "type-NN",
      //to: ["n12"]
      from: ["n8"]
    },
    "n12": {
      id: "n12",
      label: "example",
      class: "type-TK",
      //to: []
      from: ["n11"]
    },
    "n13": {
      id: "n13",
      label: ".",
      class: "type-.",
      //to: ["n14"]
      from: ["n1"]
    },
    "n14": {
      id: "n14",
      label: "sentence",
      class: "type-TK",
      //to: []
      from: ["n13"]
    },
    "n15": {
      id: "n15",
      label: "TOP2",
      class: "type-TOP",
      //to: []
    }
  }

  // Set up an SVG group so that we can translate the final graph.
  var svg = d3.select("svg"),
    svgGroup = svg.append("g");
  // Create the renderer
  var render = new dagreD3.render();
  // Add our custom arrow (a hollow-point)
  render.arrows().hollowPoint = function normal(parent, id, edge, type) {
    var marker = parent.append("marker")
      .attr("id", id)
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 9)
      .attr("refY", 5)
      .attr("markerUnits", "strokeWidth")
      .attr("markerWidth", 8)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
      /*
          var path = marker.append("path")
            .attr("d", "M 0 0 L 10 5 L 0 10 z")
            .style("stroke-width", 1)
            .style("stroke-dasharray", "1,0")
            .style("fill", "#fff")
            .style("stroke", "#333")
            */
      // Todo:まーかーをDragしたい。。
    var sel = marker.append("rect").attr("width", 10).attr("height", 10).style("fill", "#fff").style("stroke", "#333").on("click", function(d, i) {
      if (d3.event.defaultPrevented) return;
      d.style("fill", "#666")
    })

    dagreD3.util.applyStyle(sel, edge[type + "Style"]);
  };

  // Set up zoom support
  var zoom = d3.behavior.zoom().on("zoom", function() {
    svgGroup.attr("transform", "translate(" + d3.event.translate + ")" +
      "scale(" + d3.event.scale + ")");
  });
  svg.call(zoom);

  // Set up drag support
  var nodeDrag = d3.behavior.drag()
    .on("dragstart", dragstart)
    .on("drag", dragmove);

  function clicked(d, i) {
    if (d3.event.defaultPrevented) return; // dragged
    console.time("select" + d)
    focusIn(d)
    console.timeEnd("select" + d)
  }

  var mcount = 0
  function addNode(n) {
    g.setNode(n.id, n)
    var node = g.node(n.id)

    function addEdge(f, t) {
      g.setEdge(f, t, {
        arrowhead: "hollowPoint",
        id: f + "-" + t
      })
      g.edge(f, t).lineInterpolate = 'basis'
    }
    // g.nodeオブジェクトのfrom/toデータ整備
    if (n.from) {
      n.from.forEach(function(f) {
        addEdge(f, n.id)
        // 親に自分を登録
        var nd = g.node(f) //| data[f]// これは上手くいかない
        // g.nodeに無いときはdataを参照
        if (!nd) { nd = data[f] }
        if (!nd.to) {
          nd.to = [n.id]
        } else if (!nd.to.some(function(_) { _ == n.id })) {
          nd.to.push(n.id)
        }
      })
    }
    if (n.to) {
      n.to.forEach(function(t) {
        addEdge(n.id, t)
        var nd = g.node(t) //| data[t]
        if (!nd) { nd = data[t] }
        if (!nd.from) {
          nd.from = [n.id]
        } else if (!nd.from.some(function(_) {_ == n.id})) {
          nd.from.push(n.id)
        }
      })
    }
    node.getSibling = function(count, followAncestor) {
      if (!this.from || this.from.length < 1) {
        return this.id　// 親がいなかったら自分。本当は別のルートを返したいが。。
      }
      var par = g.node(this.from[0]).to // 0 決め打ちっすか！？
      if (par.length > 1) { //兄弟がいる場合
        var pos = par.indexOf(this.id)
        return par[(pos + count + par.length) % par.length] //ループでいいのか？ followAncestorの時に範囲を超えたら親戚ノードに行った方がいいのでは？
      } else if (followAncestor) { // 一人っ子だった場合
        var ant = g.node(this.from[0]).getSibling(count, followAncestor)
        if (g.node(ant).to) { // 可能なら元いた階層に合わせる
          ant = g.node(ant).to[0] // 0 決め打ちっすか！？
        }
        return ant
      }
      return this.id // 見つからなかったら自分
    }
    mcount++
  }

  function addNodes(data) {
    for (var d in data) {
      addNode(data[d])
    }
    //console.time("addmethod render")
    render(svgGroup, g);
    //console.timeEnd("addmethod render")
    nodeDrag.call(svg.selectAll("g.node"));
    svg.selectAll("g.node").on("click", clicked)
  }
  addNodes(data)

  // 時間をかけて読み込み版,mcountとか使ってすごく適当。。
  function addNodesd() {
    addNode(data["n" + mcount])
    render(svgGroup, g);
    if (mcount > 15) { //終了
      nodeDrag.call(svg.selectAll("g.node"));
      svg.selectAll("g.node").on("click", clicked)
      return;
    }
    setTimeout(addNodesd, 200)
  }
  //addNodesd()


  // Center the graph
  var xCenterOffset = 0 //(svg.attr("width") - g.graph().width) / 2;
  svgGroup.attr("transform", "translate(" + xCenterOffset + ", 20)");
  //svg.attr("height", g.graph().height + 40);
  svg.attr("height", 600);



  var currentFocusedId = null

  function focusIn(id) {
    if(!id){
      console.log("invalid id is given. use top of g.nodes else")
      id = g.nodes()[0]
    }
    dagreD3NodeClass(id, { focused: true, temp: false })
    focusOut() // 一旦クリア
    currentFocusedId = id
    console.time("addmethods" + id)
    addMethods(id)
    console.timeEnd("addmethods" + id)
  }

  function focusOut() {
    dagreD3NodeClass(currentFocusedId, { focused: false })
    d3.selectAll(".temp").each(function(d) { removeNode(d) })
    currentFocusedId = null
  }

  function removeNode(d) {
    var node = g.node(d)
      // 関係nodeから記録を抹消
    if (node.to) {
      node.to.forEach(function(t) {
        g.node(t).from = g.node(t).from.filter(function(_) {return _ != d })
      })
    }
    if (node.from) { //fromが無いことは、、あるか。。
      node.from.forEach(function(f) {
        g.node(f).to = g.node(f).to.filter(function(_) {return _ != d })
      })
    }
    g.removeNode(d)
  }

  function dagreD3NodeClass(id, classobj) {
    if (!id) return
    console.time("nodeclass" + id)
    var cls = g.node(id)
    var cla = cls.class.split(" ")
    for (var k in classobj) {
      if (classobj[k]) {
        if (!cla.some(function(c) { return c == k })) {
          cla.push(k)
        }
      } else {
        cla = cla.filter(function(c) { return c != k })
      }
    }
    cls.class = cla.join(" ")
    g.setNode(id, cls)
      // d3obj とdagred3objの同期。。こんな。。
      //render(svgGroup, g)
    svgGroup.select("#" + id).classed(classobj) //rendarはやりすぎだから直接書き換え
    console.timeEnd("nodeclass" + id)
  }


  var methods = [{
    label: "method 1",
    class: "type-Method"
  }, {
    label: "method 2",
    class: "type-Method"
  }, {
    label: "method 3",
    class: "type-Method"
  }, ]

  function addMethods(d) {
    methods.forEach(function(m) {
      addMethod(d, m)
    })
    console.time("addmethod render")
    render(svgGroup, g);
    console.timeEnd("addmethod render")
    nodeDrag.call(svg.selectAll("g.node"));
    svg.selectAll("g.node").on("click", clicked)
  }

  function addMethod(d, method) {

    var m = $.extend(true, {}, method); // ご丁寧にd3は参照データをコピーしないのです。逆に言うとdataとg.nodeの乖離があるということ

    m.id = "n" + mcount
    m.from = [d]
    addNode(m)
    dagreD3NodeClass(m.id, { temp: true })
  }

  // handle key event
  /*
  // Return key, ↩
         '↩': 13, 'return': 13, enter: 13, '⌅': 13,
  '←': 37, left: 37, 'arrow-left': 37,
              // Up Arrow Key, or ↑
              '↑': 38, up: 38, 'arrow-up': 38,
              // Right Arrow Key, or →
              '→': 39, right: 39, 'arrow-right': 39,
              // Up Arrow Key, or ↓
              '↓': 40, down: 40, 'arrow-down': 40,
              */
  var onKey = {
   37: function() { focusIn(g.node(currentFocusedId).from[0]) },
   39: function() { focusIn(g.node(currentFocusedId).to[0]) },
   38: function() { focusIn(g.node(currentFocusedId).getSibling(1, true)) },
   40: function() { focusIn(g.node(currentFocusedId).getSibling(-1, true)) }
  }
  d3.select("body").on("keydown", function() { onKey[d3.event.keyCode]() })

// drag関連
  function dragstart(d) { d3.event.sourceEvent.stopPropagation(); }

  function dragmove(d) {
    var node = d3.select(this),
      selectedNode = g.node(d);
    var prevX = selectedNode.x,
      prevY = selectedNode.y;

    selectedNode.x += d3.event.dx;
    selectedNode.y += d3.event.dy;
    node.attr('transform', 'translate(' + selectedNode.x + ',' + selectedNode.y + ')');

    var dx = selectedNode.x - prevX,
      dy = selectedNode.y - prevY;

    g.edges().forEach(function(e) {
      if (e.v == d || e.w == d) {
        edge = g.edge(e.v, e.w);
        translateEdge(g.edge(e.v, e.w), dx, dy);
        $('#' + edge.id + " path").attr('d', calcPoints(e));
      }
    })
  }

  function translateEdge(e, dx, dy) {
    e.points.forEach(function(p) {
      p.x = p.x + dx;
      p.y = p.y + dy;
    });
  }
  //taken from dagre-d3 source code (not the exact same)
  function calcPoints(e) {
    var edge = g.edge(e.v, e.w),
      tail = g.node(e.v),
      head = g.node(e.w);
    var points = edge.points.slice(1, edge.points.length - 1);
    var afterslice = edge.points.slice(1, edge.points.length - 1)
    points.unshift(intersectRect(tail, points[0]));
    points.push(intersectRect(head, points[points.length - 1]));
    return d3.svg.line()
      .x(function(d) {
        return d.x;
      })
      .y(function(d) {
        return d.y;
      })
      .interpolate("basis")
      (points);
  }

  //taken from dagre-d3 source code (not the exact same)
  function intersectRect(node, point) {
    var x = node.x;
    var y = node.y;
    var dx = point.x - x;
    var dy = point.y - y;
    //g.node(node.customId)
    //var w = $("#" + node.customId).attr('width') / 2;
    var w = $("#" + node.id + " rect").attr('width') / 2;
    var h = $("#" + node.id + " rect").attr('height') / 2;
    var sx = 0,
      sy = 0;
    if (Math.abs(dy) * w > Math.abs(dx) * h) {
      // Intersection is top or bottom of rect.
      if (dy < 0) {
        h = -h;
      }
      sx = dy === 0 ? 0 : h * dx / dy;
      sy = h;
    } else {
      // Intersection is left or right of rect.
      if (dx < 0) {
        w = -w;
      }
      sx = w;
      sy = dx === 0 ? 0 : w * dy / dx;
    }
    return {
      x: x + sx,
      y: y + sy
    };
  }
</script>
